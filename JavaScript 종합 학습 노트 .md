# JavaScript 종합 학습 노트

## 웹 개발 3요소

| 기술 | 역할 |
| --- | --- |
| HTML | 구조 |
| CSS | 스타일 |
| JavaScript | 연산 |
|  |  |

---

## JavaScript란?

**JavaScript (JS)**는 한 줄씩 읽어 실행하는 인터프리터 언어입니다.

### JavaScript의 특징

1. 퍼즐 조각처럼 코드 형태로 HTML 페이지에 내장된다. 스크립트는 어디에도 넣을 수 있다.
2. 컴파일 과정 없이 브라우저 내부의 자바스크립트 처리기(인터프리터)에 의해 바로 실행된다.
    - 개발의 발전됨에 따라 컴파일 과정이 가능해졌으며, Node.js로 서버 환경을 구축한다.

---

## 웹 페이지에서 JavaScript의 역할

웹 페이지는 3가지 코드(HTML-정보, CSS-디자인, JS-연산)가 결합되어 작성된다.

JavaScript는 사용자의 입력을 처리하거나 웹 애플리케이션을 작성하는 등 여러가지 역할을 수행하며, **웹 페이지의 동적 제어**에 사용된다.

### 주요 역할

1. 사용자의 입력 및 연산
2. 웹 페이지 내용 및 모양의 동적 제어
3. 브라우저 제어
4. 웹 서버와의 통신
5. 웹 애플리케이션 작성

---

## JavaScript를 작성할 수 있는 위치

### 1. HTML 태그의 이벤트 리스너 속성에 작성

태그에는 마우스가 클릭되거나 키보드의 키가 입력되는 등의 이벤트(반응)가 발생한다. 이 때 처리하는 코드를 등록하는 리스너 속성이 있다.

### 2. `<script></script>` 태그 안에 작성

- `<head></head>`, `<body></body>`, body 태그 밖 등 어디든 들어갈 수 있다
- 웹 페이지 내에서 여러 번 작성할 수 있다

### 3. .js 자바스크립트 파일에 작성

자바스크립트 코드를 확장자가 .js인 파일에 별도로 저장하여 `<script src=".js경로"></script>`로 불러올 수 있다.

### 4. URL 부분에 작성

`<a>` 태그의 속성 중 `href="javascript:"`등에도 자바스크립트 코드를 작성할 수 있다. 하지만 href 속성에는 반드시 `"javascript:"`라는 키워드를 작성해야 한다.

---

## JavaScript의 역사

### 탄생

1995년, 넷스케이프 커뮤니케이션즈에서 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어를 도입했다. 이것이 **브랜던 아이크**라는 사람이 만든 자바스크립트이다.

### 표준화

- 자바스크립트의 파생 버전인 JScript를 인터넷에 탑재했으나, 표준화되지 못했다
- 브라우저에 따라 웹페이지가 정상적으로 동작하지 않는 **크로스 브라우징 이슈**가 발생해서 자바스크립트의 표준화 필요성이 대두되었다
- 컴퓨터 시스템 표준을 관리하는 비영리 기구인 **ECMA International**에서 표준화된 자바스크립트가 완성되었고 **ECMAScript**로 명명되었다
- **ECMAScript 6 (ES6)**는 let/const 키워드, 화살표 함수, 클래스, 모듈 등 범용 프로그래밍 언어로서 갖춰야 할 기능들을 대거 도입하는 큰 변화가 있었다

---

## JavaScript 제어 용어

### 이스케이프 문자

| 문자 | 의미 |
| --- | --- |
| `\n` | new line, 개행 문자, 줄바꿈 |
| `\t` | tab, 위 아래 줄 간격 맞춰 띄기 |
| `\"` | " 표현 |
| `\'` | ' 표현 |
| `\\` | 표현 |

---

## JavaScript 기본 문법

### 1. 문장 구분

- 세미콜론으로 문장과 문장을 구분한다
- 한 줄에 한 문장만 있는 경우 세미콜론을 생략할 수 있다

**예시:**

```jsx
i = i + 1
j = j + 1;
k = k + 1; m = m + 1;
n = n + 1 p = p + 1 // (X) 잘못된 문법
```

### 2. 주석

- **한 줄 주석:** `//`
- **범위 주석:** `/* */`

### 3. 데이터 타입 (원시타입)

`typeof()` 함수로 타입을 확인할 수 있다.

| 타입 | 설명 | 예시 |
| --- | --- | --- |
| number | 숫자 타입 | `42`, `3.14` |
| boolean | 논리 타입 | `true`, `false` |
| string | 문자열 타입 | `"안녕"`, `"하세요"`, `"35"`, `'a'` |
| object | 객체 레퍼런스 타입 | Object, Array, Math, Date |
| undefined | 타입이 정해지지 않은 것 |  |
| null | 값이 정해지지 않은 것 |  |

### 4. 변수

**var 키워드**

- 함수의 영역만 영역으로 판단한다

**let 키워드 (ES6)**

- 모든 영역을 영역으로 판단한다

### 5. 상수

**const 키워드**

- 값을 변경시킬 수 없다

**상수를 사용하는 이유**

1. 의미 없는 값에 의미를 부여하기 위해서
2. 오타 방지

### 6. 지역변수와 전역변수

변수의 사용 범위(scope)에 따라서 전역변수(global)와 지역변수(local)로 나뉜다.

- **전역 변수:** 영역 밖에서 선언된 변수
- **지역 변수:** 영역 안에서 선언된 변수

---

## 변수 선언 시 주의사항

- **첫 번째 문자:** 알파벳, 언더바(`_`), `$` 문자만 사용 가능
- **두 번째 이상 문자:** 알파벳, 언더바, 0-9, `$` 사용 가능
- **대소문자 구분:** `data`와 `dAta`는 다른 식별자이다
- **키워드(예약어) 사용 불가**
- **카멜 표기법 사용** (camelCase)

---

## JavaScript 연산자

### 1. 최우선 연산자 `()`

괄호로 연산 순서를 조정할 수 있다.

```jsx
10 * 4 + 4    // 44
10 * (4 + 4)  // 80
```

### 2. 단항 연산자 (항이 1개)

**증감 연산자**

- `++` : 값이 1씩 증가
- `--` : 값이 1씩 감소

**전위형과 후위형**

- 전위형: `++a` (먼저 증가 후 사용)
- 후위형: `a++` (먼저 사용 후 증가)

**부정 연산자**

- `!` : 낫 연산자, 할당된 값을 부정하는 연산자

### 3. 이항 연산자 (항 2개)

**산술 연산자**

- `+`, `-`, `*`, `/`, `%`
- `/` : 몫을 구하는 연산자
- `%` : 나머지를 구하는 연산자

**할당 연산자**

- `+=` : 값이 더해지면서 누적
- `-=` : 값이 빠지면서 누적
- `*=` : 값이 곱해지면서 누적
- `/=` : 값이 나눠지면서 누적

### 4. 시프트 연산자

- `a << b` : 피연산자를 명시한 비트 수만큼 왼쪽으로 이동시킨다
- `~` : 시프트 부정 연산자

### 5. 관계 연산자

**동등/일치 비교**

- `==` : 동등 비교
- `===` : 일치 비교
- `!=` : 부등 비교
- `!==` : 불일치 비교

**크기 비교**

- `>`, `<` : 초과, 미만
- `>=`, `<=` : 이상, 이하

### 6. 논리 연산자

**`||` 논리합 (OR)**

- 둘 중에 하나라도 true면 true
- 조건식 `||` 값으로 사용되었을 때, 조건식이 false인 경우 초기값으로 사용된다

**`&&` 논리곱 (AND)**

- 둘 다 true이어야만 true
- 자바스크립트에서는 선행 조건식이 false일 때 뒤 값을 실행하지 않는다
- 선행 조건식이 true면 뒤에 값을 반환한다

**`??` 병합 연산자**

- null 또는 undefined일 때 오른쪽 값을 반환한다

### 7. 삼항 연산자 `? :`

```jsx
조건식 ? 조건식이 true일 때 값 : 조건식이 false일 때 값
```

### 8. 대입 연산자

```jsx
a = b
```

---

# JavaScript 제어문

## 제어문이란?

프로그램의 동작 흐름에 **조건**과 **반복**을 통해 제어할 수 있는 실행문

---

## 조건문

조건문이란 프로그램 내에서 주어진 표현식의 결과에 따라 별도의 명령을 수행하도록 제어하는 실행문

### if문

조건문 중에서 가장 기본이 되는 실행문

#### 기본 if문

```jsx
if(조건식) {
    실행할 문장;
}
```

위의 조건식 결과와 상관없이 무조건 검사

#### 여러 개의 if문

```jsx
if(조건식) {
    실행할 문장;
}
if(조건식) {
    실행할 문장;
}
if(조건식) {
    실행할 문장;
}
// 모든 조건식을 독립적으로 검사
```

#### if-else if-else문

```jsx
if(조건식) {
    실행할 문장;
} else if(조건식) {
    실행할 문장;
} else if(조건식) {
    실행할 문장;
} else {
    실행할 문장;
}
```

- 위 조건식이 false일 경우만 검사
- 이전 조건이 true면 아래 조건은 검사하지 않음

### switch문

```jsx
switch(값) {
    case 값1:
        실행할 문장;
        break;
    case 값2:
        실행할 문장;
        break;
    case 값3:
        실행할 문장;
        break;
    default:
        실행할 문장;
        break;
}
```

---

## 기타 제어문

### break

즉시 해당 중괄호 영역을 탈출한다.

> **주의:** if문 안에서 사용 시 if문을 탈출하지 않고 if문을 감싸고 있는 중괄호 영역을 탈출한다.
> 

### continue

즉시 다음 반복으로 이동한다.

- 아래에 작성된 코드를 실행하고 싶지 않을 때 사용한다

---

## 삼항 연산자, if문, switch문의 비교

| 구분 | 사용 시기 |
| --- | --- |
| **삼항 연산자** | 조건식이 1개 있을 경우 사용 |
| **if문** | 조건식에 비교(`>`, `<`, `>=`, `<=`) 연산자를 사용하거나, 여러 개의 조건식을 논리 연산자(`&&`, `||`)로 연결할 때 사용 |
| **switch문** | 하나의 변수에 여러 개의 값이 담길 수 있고, 각 값이 같은지를 비교할 때 사용 |

---

## 반복문

프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문

### 대입 연산자 (복합 대입 연산자, 누적 연산자)

반복문에서 자주 사용되는 연산자

- `+=`, `-=`, `*=`, `/=`

### 반복문의 종류

1. **forEach, for..in, for..of**
2. **for문**
3. **while문**

### for문

```jsx
for(초기화; 조건식; 증감식) {
    조건식이 참일 경우 실행할 문장
}
```

**실행 순서:**

1. 초기식
2. 조건식
3. 실행할 문장
4. 증감식
5. 조건식
6. 실행할 문장
7. 증감식
8. ...반복

### while문

```jsx
while(조건식) {
    실행할 문장;
}
```

### for문과 while문의 목적

| 구분 | 사용 시기 |
| --- | --- |
| **for문** | 몇 번 반복할지 알 때 |
| **while문** | 몇 번 반복할지 모를 때 |

---

# JavaScript 함수와 프로그래밍 패러다임

## 프로그래밍 패러다임

개발자에게 프로그래머로서 관심을 갖게 하고 결정하는 역할 (개발 방법)

### 패러다임의 종류

#### 1) 명령형

**절차 지향형**

- 순서를 중요시하며 컴퓨터의 처리 구조와 비슷하게 개발
- 속도가 빠르다
- **대표 언어:** C, COBOL 등

**객체 지향형**

- 객체(집단)의 상호 작용을 중요시하며 개발
- 유지보수가 좋다
- **대표 언어:** Java, C++ 등

#### 2) 선언형

**함수 지향형**

- 순수 함수를 조합하고 프로그래밍을 하는 방법을 지향
- 재사용성이 좋다
- **대표 언어:** JavaScript 등

---

## 함수(Function)란?

코드 블록으로 감싸져 있는 문으로 이루어진 하나의 실행 단위

### 함수의 선언

```jsx
function 함수명(매개변수1, 매개변수2, ...) {
    함수를 사용했을 때 실행할 문장
    // 필요시 return
}
```

### 함수의 사용

```jsx
함수명()
```

### return

- 함수의 종료를 의미하며, return이 없다면 비즈니스 로직만 실행하고 값은 `undefined`
- return 키워드가 있다면 통째로를 return 값으로 보아야 한다

---

## 함수의 이름 짓기

함수명은 동작을 나타내는 동사로 시작하는 것이 좋다.

| 함수명 | 설명 |
| --- | --- |
| `showMessage(..)` | 메시지를 보여줌 |
| `getAge(..)` | 나이를 나타내는 값을 얻고 그 값을 반환함 |
| `calcSum(..)` | 합계를 계산하고 그 결과를 반환함 |
| `createForm(..)` | form을 생성하고 만들어진 form을 반환함 |
| `checkPermission(..)` | 승인 여부를 확인하고 true나 false를 반환함 |

---

## 함수의 규칙

1. **하나의 함수는 하나의 동작만 수행한다**
2. **함수는 이름에 언급되어 있는 동작을 반드시 수행해야 한다**
3. **언급된 기능 외의 동작을 수행하면 안 된다**

---

## 익명 함수

이름이 없는 함수

### 사용 용도

- 다른 함수의 매개 변수로 전달되어 바로 실행되는 함수
- 매개변수, 콜백 함수, 클로저, 즉시 실행 함수
- **재사용성이 없는 경우에만 바로 사용된다**

### 예시

```jsx
// 콜백 함수로 사용
setTimeout(function() {
    console.log("3초 후 실행");
}, 3000);

// 즉시 실행 함수
(function() {
    console.log("즉시 실행");
})();
```

---

# JavaScript 객체

## 객체(Object)란?

자료를 저장하고 처리하는 데이터의 가장 기본 단위이다.

추상화하여 상태와 행위를 가지는 것, 그것을 구체화한 것이 객체이다.

### JavaScript와 객체

- 자바스크립트는 **객체 기반의 스크립트 언어**이며, 자바스크립트를 이루고 있는 모든 것이라고 해도 무방하다
- 원시 타입 외에 데이터 타입은 모두 Object이다
- 자바스크립트의 객체는 **키와 값으로 구성된 속성들의 집합**이다

---

## 객체의 구성 요소

### 키(Key)

집합에서 특정한 값을 찾기 위해 다른 값들과 비교되는 값

### 값(Value)

실제 데이터

### 프로퍼티(Property)

키로 이름을 구별하고 해당 키 값으로 구성되어 있다.

**즉, 키와 값 한 쌍을 의미한다.**

**예시:**

```jsx
const person = {
    name: "홍길동",      // name(키): "홍길동"(값) → 하나의 프로퍼티
    age: 30,            // age(키): 30(값) → 하나의 프로퍼티
    city: "서울"        // city(키): "서울"(값) → 하나의 프로퍼티
};
```

---

## this 키워드

객체를 정의할 때 필드에 접근한 객체가 누구인지 알아야 해당 필드에 접근할 수 있다.

이때 접근한 객체가 가지고 있는 할당된 프로퍼티의 주소값을 `this`라는 변수에 자동으로 담긴다.

**예시:**

```jsx
const user = {
    name: "김철수",
    greet: function() {
        console.log("안녕하세요, " + this.name + "입니다.");
        // this는 user 객체를 가리킴
    }
};

user.greet(); // "안녕하세요, 김철수입니다."
```

---

## JavaScript 엔진

자바스크립트는 **싱글 쓰레드의 싱글 컨커런트 언어**이다.

이는 동시에 하나의 작업이나 하나의 코드 조각만 실행할 수 있다는 것을 의미한다.

하나의 콜 스택을 가지며, 스택은 힙, 큐와 함께 V8 엔진 내부에서 실행하는 자바스크립트 동시성 모델(Concurrency Model)을 구성한다.

### 1. 콜 스택 (Call Stack)

콜 스택에 힙에 저장된 객체의 주소값을 저장한다.

- 함수 호출을 기록하는 자료구조
- 함수가 호출되면 스택에 쌓이고, 함수가 종료되면 스택에서 제거됨

### 2. 힙 (Memory Heap)

객체는 힙, 즉 대부분 구조화되지 않은 메모리 영역에 할당된다.

변수와 객체에 대한 모든 메모리 할당은 여기에서 발생한다.

**메모리 구조:**

```jsx
┌─────────────────┐
│   Call Stack    │  ← 함수 호출, 변수 참조
├─────────────────┤
│   Memory Heap   │  ← 객체, 배열 등 저장
└─────────────────┘
```

---

# JavaScript 클래스와 DOM API

## 클래스(Class)

공통요소를 한 번만 선언해놓고 가져다 사용만 하도록 설계한다.

### 추상화란?

객체의 공통적인 특성을 추출하여 클래스로 정의하는 것

### 객체화(Instance)

추상적인 개념을 구체화시키는 작업

---

## 클래스의 선언

```jsx
class 클래스명 {
    필드, 메서드, ...
}
```

---

## 클래스 필드의 사용

### 1. 객체화(Instance)

클래스를 실제 객체로 만드는 과정

**예시:**

```jsx
hong = new Person()
```

### 2. 점(.) 연산자

**다른 이름들:**

- 하위 연산자
- 접근 연산자
- 닷 연산자
- 점 연산자

**특징:**

- 주소값 뒤에서만 사용이 가능하며 해당 주소를 참조하는 명령어이다

**예시:**

```jsx
hong.name     // 객체의 name 속성에 접근
hong.greet()  // 객체의 greet 메서드 호출
```

---

## 생성자(Constructor)

매개변수가 없는 생성자이며, 클래스 선언 시 자동으로 선언된다.

**문법:**

```jsx
constructor(변수1, 변수2, ...) {
    this.변수1 = 변수1;
    this.변수2 = 변수2;
}
```

**예시:**

```jsx
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}

const hong = new Person("홍길동", 30);
```

---

## this 키워드

필드(프로퍼티)에 접근한 객체가 누구인지 알아야 해당 필드에 접근할 수 있다.

이때 접근한 객체가 가지고 있는 인스턴스의 참조값이 this에 자동으로 담긴다.

**예시:**

```jsx
class User {
    constructor(name) {
        this.name = name;
    }
    
    greet() {
        console.log("안녕하세요, " + this.name + "입니다.");
    }
}
```

---

## static (정적 변수)

- static 키워드를 사용하면 클래스 이름으로 직접 접근할 수 있다
- static 필드는 컴파일러가 최초 한 번만 메모리에 올려주기 때문에, 객체로 접근할 필요가 없다
- 이러한 필드를 **static 필드**라고 부른다

**예시:**

```jsx
class Calculator {
    static PI = 3.14159;
    
    static add(a, b) {
        return a + b;
    }
}

// 인스턴스 생성 없이 직접 접근
console.log(Calculator.PI);
console.log(Calculator.add(5, 3));
```

---

## DOM API

### DOM API란?

**DOM (Document Object Model)**

- 문서의 객체 모델을 의미한다
- 흔히 말하는 div, span, input과 같은 요소들을 모두 DOM이라고 한다
- HTML 태그들을 하나씩 객체화한 것

**특징:**

- HTML 페이지의 내용과 모양을 제어하기 위해 사용되는 객체이다
- HTML 태그 당 DOM 객체가 하나씩 생성된다
- HTML 태그의 포함관계에 따라서 부모, 자식, 형제자매 관계로 구성된다

### API란?

**API (Application Programming Interface)**

응용 프로그램 사이에서 통신에 사용되는 언어와 메시지를 이야기한다.

---

## DOM Selector

HTML 요소를 선택하는 메서드들

### 1. HTMLCollection 반환

- `document.getElementById()` - ID로 단일 요소 선택
- `document.getElementsByClassName()` - 클래스명으로 요소들 선택
- `document.getElementsByTagName()` - 태그명으로 요소들 선택

### 2. NodeList 반환

- `document.getElementsByName()` - name 속성으로 요소들 선택
- `document.querySelector()` - CSS 선택자로 단일 요소 선택
- `document.querySelectorAll()` - CSS 선택자로 요소들 선택

**예시:**

```jsx
// ID로 선택
const header = document.getElementById('header');

// 클래스로 선택
const buttons = document.getElementsByClassName('btn');

// CSS 선택자로 선택
const firstButton = document.querySelector('.btn');
const allButtons = document.querySelectorAll('.btn');
```

---

# JavaScript 이벤트

## 자주 사용되는 이벤트

### 마우스 이벤트

**click** - 요소를 클릭했을 때

```jsx
element.addEventListener('click', function(event) {
  console.log('요소가 클릭되었습니다!');
});
```

**mouseover** - 요소에 마우스를 올렸을 때

```jsx
element.addEventListener('mouseover', function(event) {
  event.target.style.backgroundColor = 'yellow';
});
```

**mouseleave** - 요소에서 마우스가 떠났을 때

```jsx
element.addEventListener('mouseleave', function(event) {
  event.target.style.backgroundColor = '';
});
```

**mousedown** - 요소를 누르고 마우스를 아직 떼기 이전 상태

```jsx
element.addEventListener('mousedown', function(event) {
  console.log('마우스 버튼이 눌렸습니다');
});
```

**mouseup** - 요소를 누르고 마우스를 뗀 상태 (마우스 위치가 요소 위에 있어야 함)

```jsx
element.addEventListener('mouseup', function(event) {
  console.log('마우스 버튼이 떼어졌습니다');
});
```

**mousemove** - 마우스가 움직일 때마다

```jsx
element.addEventListener('mousemove', function(event) {
  console.log(`마우스 위치: X=${event.clientX}, Y=${event.clientY}`);
});
```

**mousewheel** - 마우스 휠이 이동되었을 때

```jsx
element.addEventListener('wheel', function(event) {
  console.log('휠 이동:', event.deltaY);
});
```

### 스크롤 및 포커스 이벤트

**scroll** - 스크롤의 변화가 있을 때

```jsx
window.addEventListener('scroll', function(event) {
  console.log('스크롤 위치:', window.scrollY);
});
```

**focus** - 활성화 되어있을 때

```jsx
input.addEventListener('focus', function(event) {
  event.target.style.borderColor = 'blue';
});
```

**blur** - 포커스에서 벗어났을 때

```jsx
input.addEventListener('blur', function(event) {
  event.target.style.borderColor = '';
});
```

### 키보드 이벤트

**keypress** - 키를 누른 순간

```jsx
input.addEventListener('keypress', function(event) {
  console.log('입력된 문자:', event.key);
});
```

**keyup** - 키를 누르고 있다가 뺀 순간

```jsx
input.addEventListener('keyup', function(event) {
  console.log('키를 뗐습니다:', event.key);
});
```

**keydown** - 키를 누르고 떼기 이전인 순간

```jsx
input.addEventListener('keydown', function(event) {
  if (event.key === 'Enter') {
    console.log('엔터 키가 눌렸습니다');
  }
});
```

### 폼 이벤트

**change** - 폼 필드의 속성이 변경되었을 때

```jsx
select.addEventListener('change', function(event) {
  console.log('선택된 값:', event.target.value);
});
```

---

# JavaScript 동기와 비동기

## 프로그램 vs 프로세스 vs 쓰레드

**프로그램**

- 코드(.exe)가 실행되지 않은 상태

**프로세스**

- 실행된 프로그램

**쓰레드**

- 프로세스 처리 경로
- 비동기식 방식으로 특정 연산을 수행할 때 업무를 효율적으로 처리하기 위해 짧은 시간 안에 다양한 연산들을 마치 동시에 처리하는 것처럼 하는 것
- 예시: 쿨타임, 유튜브를 보고 있을 때, 무한스크롤 등

---

## 단일 쓰레드 vs 멀티 쓰레드

### 단일 쓰레드

- 처리 경로를 한 개만 가지고 있기 때문에 직렬적이다
- 동시에 많은 양을 처리하기 힘들기 때문에 상대적으로 비효율적이다
- 하나의 작업에 문제가 발생하더라도 다른 작업에는 영향을 끼치지 않는다
- 안정성이 보장되고 설계 시 멀티 쓰레드에 비해 쉽다

### 멀티 쓰레드

- 하나의 프로세스를 동시에 처리하는 것처럼 보이지만 사실은 매우 짧은 단위로 분할해서 차례로 처리한다
- 여러 개의 처리 경로를 가질 수 있도록 하며, 동시 작업이 가능해진다
- 설계하기 굉장히 어려우며, 하나의 쓰레드 문제 발생 시 모든 쓰레드에 문제가 발생하게 된다
- **장점**: 처리량 증가, 효율성 증가, 처리비용 감소
- 장점이 크기 때문에 단점을 감수하고 설계하는 편이다

---

## 동기(Synchronous) 프로그래밍

**개념**

- 작업을 순차적으로 처리하는 방식 (왼쪽에서 오른쪽, 위에서 아래)
- 앞의 결과가 끝나야 다음 작업을 시작한다

**장점**

- 디버깅이 상대적으로 쉽다

**단점**

- 시간이 오래 걸리는 작업이 있으면 전체 흐름이 멈춘다
- 예시: 네트워크/웹 통신 I/O, DB I/O, 파일 I/O 등
- 사용자의 경험이 나쁠 수 있다

---

## 비동기(Asynchronous) 프로그래밍

**개념**

- 작업을 백그라운드(리버브)에서 처리하고, 나중에 결과가 도착하면 알림(new promise()에서)을 받는다
- 기다리지 않고 다음 작업을 바로 실행한다

**장점**

- 긴 작업 중에도 다른 작업을 동시에 수행할 수 있음 (동기의 반대)
- 자원을 더 효율적으로 사용 가능 (특히 I/O 작업에 적합)

**단점**

- 코드 흐름이 복잡해질 수 있음 (콜백 지옥, Promise 체인, async/await 등)
- 디버깅이 어렵다

**비동기 예시**

1. 데이터를 요청하는 것
2. 몇 초마다, 몇 초 뒤의 코드 사용
3. 파일, 이미지

---

## 참고 자료

[JSONPlaceholder](https://jsonplaceholder.typicode.com/) - JSON 더미데이터

---

# JavaScript 에러

## 에러핸들링(Error Handling)

### 오류의 종류

#### 1. 컴파일 오류

- 실행할 수 없는 상태를 의미한다
- 코드에 빨간 줄이 들어가 있는 경우

#### 2. 빌드 오류

- 컴파일이 완료되어 만들어지면서 생기는 오류를 의미한다

#### 3. 런타임 오류

- 실행 중일 때 발생하는 오류
- 한 번이라도 정상적으로 실행되었고, 사용자에 의해서 생긴 오류를 의미한다

---

## try ~ catch문

**구조**

```jsx
try {
  // 예외가 발생할 수 있는 문장
} catch (error) {
  // 예외 발생 시 실행할 문장
} finally {
  // 예외 발생 여부에 상관없이 무조건 실행할 문장
  // catch로 잡지 못하는 오류들을 실행해야 할 때
}
```

---

## 에러 객체의 프로퍼티

### name

- 에러 이름
- 정의되지 않은 변수 때문에 발생한 에러라면 'ReferenceError'가 이름이 된다

**예시**

```jsx
try {
  console.log(undefinedVariable);
} catch (error) {
  console.log(error.name); // "ReferenceError"
}
```

### message

- 에러 상세 내용을 담고 있는 메시지를 의미한다

**예시**

```jsx
try {
  throw new Error("사용자 정의 에러 메시지");
} catch (error) {
  console.log(error.message); // "사용자 정의 에러 메시지"
}
```

### stack (비표준 프로퍼티)

- 표준은 아니지만 name과 message 외의 대부분의 호스트 환경에서 지원하는 프로퍼티들도 존재한다
- 가장 널리 사용되는 비표준 프로퍼티 중 하나이다
- 현재 호출 스택, 에러를 유발한 중첩 호출들을 순서대로 정보를 가진 문자열로 나열하며, 디버깅 목적으로 사용된다

**예시**

```jsx
try {
  throw new Error("스택 추적 테스트");
} catch (error) {
  console.log(error.stack);
  // Error: 스택 추적 테스트
  //   at <anonymous>:2:9
  //   ...
}
```